const fs = require('fs');
const path = require('path');

const filePath = path.join(__dirname, '..', 'songs', 'deep2_like_addicted_poison.json');

// 복원할 E1 값들 (이전 스크립트 실행 로그를 기반으로 수동으로 추가해야 함)
const revertMap = {
  "一天 的时间 其实说多也不算多": {
    "一天": "시간의 단위로, '하루'를 의미하는 명사입니다.",
    "的": "소유격을 나타내는 조사로, '~의'라는 의미입니다.",
    "时间": "시간을 의미하는 명사입니다.",
    "其实": "사실을 강조하는 부사로, '사실'이라는 의미입니다.",
    "说": "말하다라는 의미의 동사입니다.",
    "多": "양이 많음을 나타내는 형용사입니다.", // 중복 T1은 마지막 것으로 처리되므로, T0별로 정확히 매핑해야 함
    "算": "계산하거나 간주하다라는 의미의 동사입니다."
  },
  "好多 时钟的圈 足够想念你了七遍": {
    "好多": "양이 많음을 나타내는 형용사입니다.",
    "时钟": "시간을 나타내는 기계 장치를 의미하는 명사입니다.",
    "的": "소유나 속성을 나타내는 조사입니다.",
    "圈": "원형으로 돌거나 회전하는 것을 의미하는 명사입니다.",
    "足够": "필요한 양이나 정도에 도달했음을 나타내는 부사입니다.",
    "想念": "누군가를 보고 싶어하거나 생각하는 감정을 표현하는 동사입니다."
  },
  "旁边 是谁 怎么我没看过他的脸": {
    "旁边": "어떤 장소나 사물의 근처를 가리키는 명사입니다.",
    "谁": "누군가를 가리키는 대명사입니다.", // 원본이 없으면 기존 상태 유지됨
    "怎么": "이유나 방법을 묻는 의문사입니다.",
    "没": "부정을 나타내는 부사로, 과거의 부정을 표현할 때 사용됩니다.",
    "看过": "경험을 나타내는 표현으로, '看'은 '보다', '过'는 경험을 나타내는 조동사입니다.",
    "脸": "얼굴을 의미하는 명사입니다."
  },
  "奇怪 这感觉 明明我知道很危险": {
    "奇怪": "일반적이지 않거나 이해하기 어려운 상황을 표현하는 형용사입니다.",
    "感觉": "신체적 또는 정신적으로 받는 감각이나 인상을 의미하는 명사입니다.",
    "明明": "사실이 확실함을 강조하는 부사입니다.",
    "知道": "어떤 사실이나 정보를 이해하고 있는 상태를 나타내는 동사입니다.",
    "危险": "해로울 가능성이 있는 상태를 나타내는 형용사입니다."
  },
  "飞蛾 总在 危险时候把自己奉献": {
    "飞蛾": "밤에 불빛에 이끌리는 곤충인 나방을 의미합니다. 여기서는 위험을 무릅쓰는 존재의 상징으로 사용되었습니다.",
    "总": "항상 또는 전체를 의미하는 부사입니다.", // 원본이 없으면 기존 상태 유지됨
    "时候": "특정 시점이나 기간을 나타내는 명사입니다.", // 원본이 없으면 기존 상태 유지됨
    "把": "목적어를 동사 앞으로 끌어내어 강조하는 전치사입니다.",
    "自己": "말하는 사람 자신을 가리키는 재귀대명사입니다.",
    "奉献": "자신의 것을 희생하여 남에게 주거나 어떤 목적을 위해 쏟아붓는 것을 의미합니다."
  },
  "乱了一切": {
    "乱": "무질서하게 만들거나 혼란스럽게 하는 동사입니다.",
    "一切": "모든 사물이나 상황을 포괄적으로 지칭하는 명사입니다."
  },
  "我像是中了你的毒 快乐藏不住": {
    "像是": "비슷하거나 유사함을 나타내는 표현으로, 추측이나 비유를 할 때 사용합니다.",
    "中": "어떤 상황에 처하거나 영향을 받는 것을 나타내는 동사입니다.", // 원본이 없으면 기존 상태 유지됨
    "毒": "해로운 물질이나 중독성을 비유적으로 나타내는 명사입니다.",
    "快乐": "기쁨이나 행복을 나타내는 명사입니다.",
    "藏": "무언가를 숨기거나 감추는 행위를 나타내는 동사입니다.",
    "住": "동사 뒤에 붙어 동작의 완료나 결과를 나타내는 보어입니다." // 원본이 없으면 기존 상태 유지됨
  },
  "再次假装不在乎 你面前装酷": {
    "再次": "어떤 행동을 반복하거나 재차 시도함을 나타내는 부사입니다.",
    "假装": "실제와는 다르게 행동하거나 속이는 것을 의미하는 동사입니다.",
    "在乎": "마음속으로 중요하게 여기거나 신경 쓰는 것을 의미하는 동사입니다.", // 원본이 없으면 기존 상태 유지됨
    "面前": "공간적으로 어떤 사람이나 사물의 정면에 위치함을 나타내는 명사입니다.",
    "装": "옷을 입거나 꾸미는 것을 의미하는 동사입니다. 여기서는 태도를 꾸미는 것을 나타냅니다.", // 원본이 없으면 기존 상태 유지됨
    "酷": "멋있거나 시원한 느낌을 주는 형용사입니다." // 원본이 없으면 기존 상태 유지됨
  },
  "其实我需要你 so there's no monday blue": {
    "其实": "사실을 강조하는 부사로, 진실이나 실제 상황을 나타낼 때 사용합니다.",
    "需要": "무엇이 필요하거나 요구된다는 의미의 동사입니다.",
    "monday blue": "월요병을 뜻하는 영어 표현입니다." // 원본이 없으면 기존 상태 유지됨
  },
  "再次隐藏着喜怒 thought it's pretty cool": {
    "再次": "부사로, 어떤 행동이나 상태가 반복됨을 나타냅니다.",
    "隐藏": "무언가를 숨기거나 감추는 동사입니다.", // 원본이 없으면 기존 상태 유지됨
    "喜怒": "명사로, 기쁨과 화남을 아우르는 감정을 나타냅니다.",
    "thought": "과거 시제 동사로, '생각하다'의 과거형입니다.",
    "pretty cool": "매우 멋지다는 뜻의 영어 구문입니다." // 원본이 없으면 기존 상태 유지됨
  },
  "发现我需要你 so there's no monday blue": {
    "发现": "무엇을 깨닫거나 알게 되다는 의미의 동사입니다.",
    "需要": "무엇이 꼭 있어야 한다는 뜻을 나타내는 동사입니다.",
    "monday blue": "월요일의 우울함을 나타내는 영어 표현입니다." // 원본이 없으면 기존 상태 유지됨
  },
  "I got lots of work 等着我去慢慢完成": {
    "lots of work": "많은 양의 일을 의미하는 영어 구문입니다.", // 원본이 없으면 기존 상태 유지됨
    "等着": "무엇을 기다린다는 의미의 동사입니다.",
    "慢慢": "느린 속도를 나타내는 부사입니다.",
    "完成": "무엇을 끝내거나 완성한다는 의미의 동사입니다."
  },
  "But the brain just fart 昨晚那路口的红灯": {
    "brain just fart": "갑자기 멍해지거나 바보 같은 생각을 하는 것을 비유하는 영어 관용구입니다.", // 원본이 없으면 기존 상태 유지됨
    "昨晚": "지난 밤을 의미하는 시간 명사입니다.",
    "路口": "길이 만나는 지점을 의미하는 명사입니다.",
    "的": "소유나 속성을 나타내는 구조조사입니다.",
    "红灯": "정지 신호를 나타내는 빨간색 신호등을 의미합니다."
  },
  "目光都变炙热 一切都停滞了": {
    "目光": "사람의 눈빛이나 시선을 나타내는 명사입니다.",
    "变": "변화를 나타내는 동사로, '변하다', '달라지다'라는 뜻입니다.",
    "炙热": "매우 뜨겁거나 열정적인 상태를 나타내는 형용사입니다.",
    "一切": "모든 것을 포괄적으로 지칭하는 대명사입니다.",
    "停滞": "움직임이나 진행이 멈추는 것을 나타내는 동사입니다."
  },
  "梦到与你一起走在沙滩上的温柔": {
    "梦到": "'꿈을 꾸다'라는 의미의 동사구입니다. 꿈속에서 어떤 경험을 했다는 것을 표현할 때 사용합니다.",
    "一起": "'함께'라는 의미의 부사입니다. 여러 사람이 같이 행동함을 나타냅니다.",
    "走在": "'걷다'라는 의미의 동사구입니다. 특정 장소에서 걷는 행위를 나타냅니다.",
    "沙滩": "해변이나 강가에 있는 모래밭을 의미하는 명사입니다.", // 원본이 없으면 기존 상태 유지됨
    "的": "소유나 관계를 나타내는 구조조사입니다. 앞의 내용이 뒤의 명사를 수식하는 역할을 합니다.",
    "温柔": "'부드러움'이라는 의미의 형용사입니다. 따뜻하고 상냥한 느낌을 표현합니다."
  },
  "一道一道阳光让我身处粉红宇宙": {
    "一道一道": "하나하나, 한 줄기 한 줄기를 의미하는 표현입니다.", // 원본이 없으면 기존 상태 유지됨
    "阳光": "태양에서 나오는 빛을 의미하는 명사입니다.",
    "让": "사동을 나타내는 동사로, 어떤 상태나 행동을 유발함을 의미합니다.",
    "身处": "어떤 장소나 상황에 놓여있음을 나타내는 동사입니다.",
    "粉红": "분홍색을 의미하는 형용사입니다.",
    "宇宙": "우주를 의미하는 명사입니다."
  },
  "这一刻 我想我 像是": {
    "这一刻": "지금 이 순간을 가리키는 시간 표현입니다.", // 원본이 없으면 기존 상태 유지됨
    "像是": "비유를 나타내는 표현으로, 어떤 상태나 상황과 유사함을 나타냅니다."
  }
  // 추가적인 T0와 T1, 그리고 원래 E1 값을 여기에 계속 추가해야 합니다.
  // 모든 변경된 항목에 대한 원본 E1 값을 포함해야 정확한 복원이 가능합니다.
};

try {
  let rawData = fs.readFileSync(filePath, 'utf-8');
  let data = JSON.parse(rawData);
  let changesMade = 0;

  if (data && Array.isArray(data.translatedLines)) {
    data.translatedLines.forEach(line => {
      if (line.LI && Array.isArray(line.LI)) {
        const t0Key = line.T0; // 현재 T0 값을 키로 사용
        if (revertMap[t0Key]) {
          line.LI.forEach(item => {
            if (revertMap[t0Key][item.T1]) {
              let originalE1 = item.E1;
              item.E1 = revertMap[t0Key][item.T1];
              if (originalE1 !== item.E1) {
                changesMade++;
                console.log(`Reverted E1 for T0: "${line.T0}" | T1: "${item.T1}"`);
                console.log(` - E1 (Current): "${originalE1}"`);
                console.log(` - E1 (Reverted to): "${item.E1}"`);
                console.log('---');
              }
            }
          });
        }
      }
    });

    if (changesMade > 0) {
      fs.writeFileSync(filePath, JSON.stringify(data, null, 2), 'utf-8');
      console.log(`\nSuccessfully reverted ${changesMade} E1 fields in ${filePath}.`);
    } else {
      console.log(`\nNo E1 fields were reverted in ${filePath}. Make sure revertMap is populated correctly.`);
    }
  } else {
    console.error('Error: Could not find translatedLines array or data structure is not as expected.');
  }
} catch (error) {
  console.error('Error processing the file:', error);
} 