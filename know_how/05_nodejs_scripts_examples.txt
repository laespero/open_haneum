# 4.4. 기존 작업 사례 요약 (예시)

## 4.4.1. 일본어 가사 연결성 개선 (`deep_last_teen.json`)

*   **문제점**: `deep_last_teen.json` 파일의 `translatedLines`에서 `T0: \"いつからで\"`와 `T0: \"いつまでなの?\"`에 해당하는 `K0` 번역(\"언제부터였을까\", \"언제까지인 거야?\")이 앞선 \"진정한 어른이란\"이라는 질문과 자연스럽게 연결되지 않고, 각 라인이 독립적인 질문처럼 느껴지는 부자연스러움이 있었습니다.
*   **해결 과정**: Node.js 스크립트를 사용하여 해당 `K0` 값을 수정하여 문맥적 흐름을 개선했습니다.
*   **수정 내용**:
    *   `T0: \"いつからで\"`의 `K0`를 `\"언제부터고,\"`로 변경.
    *   `T0: \"いつまでなの?\"`의 `K0`를 `\"언제까지인 걸까?\"`로 변경.
    *   결과: "진정한 어른이란 언제부터고, 언제까지인 걸까?\"로 자연스럽게 연결됨.

## 4.4.2. 영어 가사 예문 및 설명 수정 (`deep_mad_at_disney.json`)

`deep_mad_at_disney.json` 파일을 처리하면서 다양한 유형의 검증 및 수정 스크립트를 활용했습니다. 이는 복잡한 데이터 처리 작업의 효율성과 정확성을 높이는 데 크게 기여했습니다.

*   **예문 필드(`XE`, `XK`, `XI`, `XR`) 일괄 검증 및 기본 규칙 적용**: 데이터의 기본 규칙(예: 특정 필드 쌍의 동시 존재 또는 동시 부재)을 스크립트로 검증.
*   **IPA/병음 필드 슬래시(` / `) 일괄 제거**: 정규 표현식이나 문자열 함수를 사용한 일괄 데이터 정리.
    ```javascript
    const stripSlashes = (ipaString) => {
      if (typeof ipaString === 'string' && ipaString.startsWith('/') && ipaString.endsWith('/')) {
        return ipaString.substring(1, ipaString.length - 1);
      }
      return ipaString;
    };
    // ... 반복문 내에서 각 IPA 필드(I0, I1, I2, XI)에 적용 ...
    if (line.I0 && line.I0 !== stripSlashes(line.I0)) { /* ... */ }
    if (item.XI && item.XI !== stripSlashes(item.XI)) { /* ... */ }
    ```
*   **매우 구체적인 단일 예문 항목 수정**: 여러 필드 값을 조합하여 특정 대상을 찾아 수정.
*   **특정 예문 전체 교체**: 복잡한 조건으로 대상을 찾고, 여러 필드 동시 업데이트.
*   **용어 설명(`E1`) 및 관련 필드(`K1`, `K2`) 수정**: 하나의 정보가 여러 필드에 걸쳐 표현될 경우, 관련 필드 모두의 일관성을 유지하며 수정.

이러한 스크립트 활용은 수작업으로 인한 오류를 줄이고, 대량의 데이터에 대한 반복적인 수정을 효율적으로 처리하는 데 필수적입니다.

## 4.4.3. 일본어 예문 `XI` 필드 수정 및 데이터 경로 문제 해결 (`deep_no_regret.json`)

*   **문제점**: `deep_no_regret.json` 파일에서 특정 일본어 예문(`XE`)의 발음 표기(`XI`)를 수정하는 스크립트를 작성했으나, 스크립트가 수정 대상을 찾지 못하는 문제가 반복되었습니다.
*   **초기 시도 및 오류**:
    1.  처음에는 `contextText` 배열 내의 객체에서 `T0` 필드 값으로 대상을 찾고, 그 안의 `LI` 배열을 탐색하려 했습니다.
    2.  디버깅 결과, `T0` 값으로 찾은 객체에는 `LI` 배열이 존재하지 않았습니다. (`JSON.stringify(contextItem)`으로 확인)
    3.  이후 `LI` 배열을 직접 순회하며 `T1`과 `XE` 값으로 대상을 찾으려 했으나, 여전히 실패했습니다.
    4.  추가 디버깅(`Object.keys(contextItem)` 등)을 통해, 스크립트가 순회하던 `jsonData.contextText` 배열의 모든 요소에는 `LI` 키 자체가 없음을 발견했습니다.
*   **근본 원인 및 해결**:
    *   스크립트의 주 순회 대상을 `jsonData.contextText.forEach(...)`에서 `jsonData.translatedLines.forEach(...)`로 변경하자 문제가 해결되었고, 정확한 `LI` 항목을 찾아 `XI` 필드를 성공적으로 수정할 수 있었습니다.
*   **주요 교훈**:
    *   **JSON 데이터의 정확한 계층 구조 파악**: 스크립트 작성 전, 수정 대상 데이터가 JSON 파일 내 어떤 경로(어떤 상위 키들의 조합)를 통해 접근해야 하는지 명확히 파악하는 것이 매우 중요합니다. 가이드 문서의 구조 예시를 주의 깊게 살펴보고, 실제 파일의 구조와 일치하는지 확인해야 합니다.
    *   **체계적인 디버깅의 중요성**: 예상과 다른 결과가 나올 경우, 데이터 접근 경로의 각 단계를 `console.log`와 `JSON.stringify`, `Object.keys` 등을 활용하여 실제 데이터의 존재 여부, 타입, 구조, 값을 직접 확인하며 문제의 원인을 체계적으로 추적해야 합니다. 단순히 `if` 조건문이 실패하는 것만 볼 것이 아니라, 그 조건문에 사용된 변수들이 올바른 값을 가지고 있는지, 올바른 객체/배열에 접근하고 있는지 근본적인 부분을 점검해야 합니다. 